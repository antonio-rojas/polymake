#  Copyright (c) 1997-2014
#  Ewgenij Gawrilow, Michael Joswig (Technische Universitaet Berlin, Germany)
#  http://www.polymake.org
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#-------------------------------------------------------------------------------

object Polytope<Float> {

CREDIT cddlib

rule cdd.simplex: LP.MAXIMAL_VALUE, LP.MAXIMAL_VERTEX, FEASIBLE : LP.LINEAR_OBJECTIVE, FACETS | INEQUALITIES {
   cdd_solve_lp($this, $this->LP, 1);
}
weight 3.10;

rule cdd.simplex: LP.MINIMAL_VALUE, LP.MINIMAL_VERTEX, FEASIBLE : LP.LINEAR_OBJECTIVE, FACETS | INEQUALITIES {
   cdd_solve_lp($this, $this->LP, 0);
}
weight 3.10;

}


# @category Optimization
# Read a linear programming problem given in LP-Format (as used by cplex & Co.)
# and convert it to a [[Polytope<Float>]] object
#
# **WARNING** The property FEASIBLE is **NOT** computed upon creation.
# This is done to avoid possibly long computation times before the object becomes available to the caller.
# This is **NOT** in keeping with standard practice in polymake, but after, all, these are linear programs
# and not polytopes.
#
# @param String file filename of a linear programming problem in LP-Format
# @option Vector testvec If present, after reading in each line of the LP it is checked whether testvec fulfills it
# @option String prefix If testvec is present, all variables in the LP file are assumed to have the form $prefix$i
# @return Polytope<Float>

user_function lp2poly<Scalar=Float>($;$$) {
   require LPparser;
   my ($filename, $testvec, $prefix) = @_;

   my $parser = defined($testvec) 
                         ? new LPparser($filename, $testvec, $prefix) 
                         : new LPparser($filename);

   my $P=new Polytope<Scalar>($parser->name);
   $P->description = "Linear problem converted from file " . $parser->LPfile . "\n";
   $P->COORDINATE_LABELS = new Array<String>($parser->X);
   my $d = $P->COORDINATE_LABELS->size();

   # FIXME #702: change the following kludge to 
   # $P->INEQUALITIES = new SparseMatrix<Scalar>($parser->Ineq)
   my @AoH = $parser->Ineq;
   my $Mineq = new SparseMatrix<Scalar>(scalar @AoH, $d);
   my $i=0;
   foreach my $ineq (@AoH) {
      keys %{$ineq};
      while (my ($k,$v) = each %{$ineq}) {
         $Mineq->[$i]->[$k] = $v;
      }
      $i++;
   }
   $P->INEQUALITIES = $Mineq;

   # FIXME #702: change the following kludge to 
   # $P->EQUATIONS = new SparseMatrix<Scalar>($parser->Eq)
   @AoH = $parser->Eq;
   my $MEq = new SparseMatrix<Scalar>(scalar @AoH, $d);
   $i=0;
   foreach my $eq (@AoH) {
      keys %{$eq};
      while (my ($k,$v) = each %{$eq}) {
         $MEq->[$i]->[$k] = $v;
      }
      $i++;
   }
   $P->EQUATIONS = $MEq;

   my $lp=new LinearProgram<Scalar>;
   $lp->description="Objective sense was ".($parser->objsense eq "+" ? "MAXIMIZE" : "MINIMIZE")."\n";

   # FIXME #702: change the following kludge to 
   # $P->LINEAR_OBJECTIVE = new SparseVector<Scalar>($parser->Obj)
   my $ObjHash = $parser->Obj;
   my $ObjVect = new SparseVector<Scalar>($d);
   keys %{$ObjHash};
   while (my ($k,$v) = each %{$ObjHash}) {
      $ObjVect->[$k] = $v;
   }
   $lp->LINEAR_OBJECTIVE=$ObjVect;

   if (@{$parser->Int}) {
      $lp->attach("INTEGER_VARIABLES", new Array<Bool>($parser->Int));
   }
   $P->add("LP",$lp);
#   $P->commit;   # removed this line as we explicitly do not check for FEASIBLE on possibly large LP's
   $P;
}


# Local Variables:
# mode: perl
# cperl-indent-level:3
# indent-tabs-mode:nil
# End:
