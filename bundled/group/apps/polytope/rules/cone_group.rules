#  Copyright (c) 1997-2015
#  Ewgenij Gawrilow, Michael Joswig (Technische Universitaet Berlin, Germany)
#  http://www.polymake.org
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#-------------------------------------------------------------------------------


object Cone {

CREDIT sympol
  A software package for polyhedral description conversion up to symmetries.
  Written by Thomas Rehn and Achill SchÃ¼rmann.
  http://www.math.uni-rostock.de/~rehn/software/sympol.html 


rule GROUP.REPRESENTATIVE_RAYS : GROUP.GENERATORS, GROUP.DOMAIN, FACETS, LINEAR_SPAN {
   if ($this->GROUP->DOMAIN != $domain_OnFacets) {
      croak("Incompatible group action: expected action OnFacets.");
   }
   my $rayCompMethod = 0; # TODO: provisional: chooses sympol ray computation via lrs (set to 1 for computation via cdd)
   my ($success, $ineq, $eq) = representation_conversion_up_to_symmetry($this, $this->GROUP, 0, $rayCompMethod);
   if (!$success) {
      croak("internal sympol error");
   }
   $this->GROUP->REPRESENTATIVE_RAYS = $ineq;
}
weight 5.10;

rule GROUP.REPRESENTATIVE_LINEAR_SPAN, GROUP.REPRESENTATIVE_FACETS : GROUP.GENERATORS, GROUP.DOMAIN, RAYS, LINEALITY_SPACE {
   if ($this->GROUP->DOMAIN != $domain_OnRays) {
      croak("Incompatible group action: expected action OnRays.");
   }
   my $rayCompMethod = 0; # TODO: provisional: chooses sympol ray computation via lrs (set to 1 for computation via cdd)
   my ($success, $ineq, $eq) = representation_conversion_up_to_symmetry($this, $this->GROUP, 1, $rayCompMethod);
   if (!$success) {
      croak("internal sympol error");
   }
   $this->GROUP->REPRESENTATIVE_FACETS = $ineq;
   $this->GROUP->REPRESENTATIVE_LINEAR_SPAN = $eq;
}
weight 5.10;

CREDIT off


rule GROUP.N_REPRESENTATIVE_RAYS : GROUP.REPRESENTATIVE_RAYS {
   $this->GROUP->N_REPRESENTATIVE_RAYS = $this->GROUP->REPRESENTATIVE_RAYS->rows;
}

rule GROUP.N_REPRESENTATIVE_FACETS : GROUP.REPRESENTATIVE_FACETS {
   $this->GROUP->N_REPRESENTATIVE_FACETS = $this->GROUP->REPRESENTATIVE_FACETS->rows;
}


# @category Combinatorics
# The equivalence classes of maximal-dimensional simplices under a symmetry group 
rule GROUP.REPRESENTATIVE_SIMPLICES : COMBINATORIAL_DIM, RAYS, GROUP.GENERATORS {
    my $cds = representative_simplices($this->COMBINATORIAL_DIM, $this->RAYS, $this->GROUP->GENERATORS);
    $this->GROUP->REPRESENTATIVE_SIMPLICES = $cds;
}

# @category Combinatorics
# The number of equivalence classes of maximal-dimensional simplices under a symmetry group 
rule GROUP.N_REPRESENTATIVE_SIMPLICES : GROUP.REPRESENTATIVE_SIMPLICES {
    my $cds = $this->GROUP->REPRESENTATIVE_SIMPLICES;
    my @n_vector = map { $cds->[$_]->size } (0..$cds->size-1);
    $this->GROUP->N_REPRESENTATIVE_SIMPLICES = \@n_vector;
}

# @category Combinatorics
# The equivalence classes of maximal-dimensional simplices in the interior and boundary under a symmetry group 
rule GROUP.REPRESENTATIVE_INTERIOR_RIDGE_SIMPLICES, GROUP.REPRESENTATIVE_MAX_BOUNDARY_SIMPLICES : COMBINATORIAL_DIM, RAYS_IN_FACETS, RAYS, GROUP.GENERATORS {
    my $pair = representative_interior_and_boundary_ridges($this);
    $this->GROUP->REPRESENTATIVE_INTERIOR_RIDGE_SIMPLICES = $pair->first;
    $this->GROUP->REPRESENTATIVE_MAX_BOUNDARY_SIMPLICES = $pair->second;
}

# @category Symmetry
# The equivalence classes of maximal-dimensional simplices in the boundary under a symmetry group 
rule GROUP.REPRESENTATIVE_MAX_INTERIOR_SIMPLICES : COMBINATORIAL_DIM, RAYS, GROUP.GENERATORS {
    $this->GROUP->REPRESENTATIVE_MAX_INTERIOR_SIMPLICES = representative_max_interior_simplices($this->COMBINATORIAL_DIM, $this->RAYS, $this->GROUP->GENERATORS);
}


}

sub symmetrized_cocircuit_equations;

# @category Symmetry
# calculate the projection of the cocircuit equations to a direct sum of isotypic components
# @param Cone P
# @param Set<Int> the list of indices of the isotypic components to project to; default {0}, which
# amounts to summing all cocircuit equations corresponding to the orbit of each ridge.
# @option reduce_rows Should we return only linearly independent equations? default: true
user_function symmetrized_cocircuit_equations<Scalar>(Cone<Scalar> group::PermutationRepresentationOnSets; Set<Int>=(new Set<Int>([0])) { "reduce_rows" => 1 }) { 
    my ($p, $rep, $irrep_array, $options) = @_;
    my @total_basis;
    my $irreps = new Set<Int>($irrep_array);
    foreach my $i (@{$irreps}) {
        my $isotypic_component = $rep->give("ISOTYPIC_COMPONENT", IRREP=>$i);
        foreach (@{$isotypic_component->SPARSE_BASIS}) {
            push @total_basis, $_;
        }
    }
    return symmetrized_cocircuit_equations($p->RAYS, $p->GROUP->REPRESENTATIVE_INTERIOR_RIDGE_SIMPLICES, $irreps, $rep->GROUP->CHARACTER_TABLE, $rep->GROUP->CONJUGACY_CLASSES, (new Array<HashMap<boost_dynamic_bitset,Rational>>(\@total_basis)), $options->{"reduce_rows"});
}



# Local Variables:
# mode: perl
# cperl-indent-level:3
# indent-tabs-mode:nil
# End:
